---
title: "Calculating effect sizes using the metafor package"
author: "Nathan Brouwer"
date: "November 12, 2018"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction

In order to do a meta-analysis or meta-analysis type work up of a data set we need to calculate effect sizes.  The metafor package in R ([Viechtbauer 2010](https://www.jstatsoft.org/article/view/v036i03)) can be used to calculate effect sizes and carry out meta analyses.

Effect sizes are usually based on 2 quantities

1. The mean of 2 groups, such as control and experimentally treated organisms.
1. The standard deviation of the 2 groups.

The means and SDs of each group for a single study are then converted into an effects size, such as Cohen's d or a response ratio, which summarizes the differene between the two treatments.  Effect sizes from multiple studies are then combined in a meta-analysis.

In this tutorial we'll calcualte the necessary summary statistics using dplyr, and then effect sizes using metafor.  We'll calculate effect sizes for each of the 18 alleles investigated by a single section of the Neuro Defects lab.

## Preliminaries

### Load packages

```{r}
library(shroom)
library(metafor)
```

### Load data

```{r}
data("wngscrs_sxn1")
```


## Summarizing data by group

To use metafor to calculate effect sizes, you must first have means and SDs.  We are working with raw data from a multi-layered study and so will calculate these ourselves from the data; normally for a meta-analysis you extract this information from a published paper.

Summary stats can easily be worked up with dplyr's group_by() and summarize() commands.

In the following code we'll summarize data for the 18 alleles.  We pass 3 things to group_by: the experiemntal group (E or C), the allele designation ("gene.allele") and the allele name ("allele").  "gene.allele" and "allele" contain redunant information; "allele" is the precise name of the mutated gene (eg "abl[2]") while "gene.allele" is just the name of the gene and a numeric code (1, 2 or 3) indicating the order which the alleles are organized in the dataset.

We also include "student.ID" to further distinquish the seperate datasets (each student works on a single allele).
```{r}
sxn1_summary <- wngscrs_sxn1 %>% 
  group_by(E.or.C,
           gene.allele,
           allele, 
           student.ID) %>% 
  summarize(mean = mean(wing.score),
            sd = sd(wing.score),
            n = n())
```

We can look at the output; note that because dplyr creates "tibble" objects R only prints out a selection of columns.
```{r}
sxn1_summary
```






## Calculate effect sizes 

metafor has a function, escalc(), which returns an effect size when given a mean and standard deviation.  The form that you give data to escalc() depends on how you worked up the data.

We'll first examine a simple case of calculating a single effect size, then work up all of our data.

### Effect size walk through

Let's first look at a simple case: an effect size for a single allele.  I'll find the control and experimental results for the abl[2] allele, which is the 1st of 3 able alleles and so is also referred to as "abl.1".


First I'll find the indices of the 2 desired rows of data
```{r}
i.able.1 <- which(sxn1_summary$gene.allele == "abl.1")
```

Then pull them up
```{r}
abl.1 <- sxn1_summary[i.able.1, ]
```

An the Cohen's d effect size for the impact of the experimental treatment on fly wing phenotype would be calcualted as (mean.1 - mean.2)/("pooled" SD), where the pooled SD is a weighted average the the two standard deviations.

metafor's escalc() function luckily calcualtes the pooled SD for us, so we just have to give it the two means, the two SDs, and the two sample sizes.

I can isolate the means like this

```{r}
mean.C <- abl.1$mean[1]
mean.E <- abl.1$mean[2]
```

And similarly the SDs and Ns like this
```{r}
sd.C <- abl.1$sd[1]
sd.E <- abl.1$sd[2]

n.C <- abl.1$n[1]
n.E <- abl.1$n[2]
```

I can then pass this to escalc().  I also have to specify a "measure", which is the name of an effect size.  I'll ask for the "SMD", which is the "standardized mean difference", which is a more generic name for Cohen's d (actually an updated version called Hedge's g)

```{r}
metafor::escalc(m1i = mean.C, m2i = mean.E, 
                sd1i = sd.C, sd2i = sd.E,
                n1i = n.C, n2i = n.E,
                measure = "SMD")
```

esclac() returns two things: "yi" and "vi".  yi is the effect size, and vi is the variance for the effects size.  This variance value is used indicate how precisely the effect size is estimate.

THere are may flavors of effect sizes.  One popular in ecology is the "log response ratio" ([Hedges et al 1999](https://esajournals.onlinelibrary.wiley.com/doi/full/10.1890/0012-9658%281999%29080%5B1150%3ATMAORR%5D2.0.CO%3B2)), which is calculated as log(mean.1/mean.2).  To get it, we use measure = "ROM", where ROM = "ratio of means" (the log is implied.)
 
 
```{r}
metafor::escalc(m1i = mean.C, m2i = mean.E, 
                sd1i = sd.C, sd2i = sd.E,
                n1i = n.C, n2i = n.E,
                measure = "ROM")
```

We can check escalc's math if we want.  The ratio of our means is

```{r}
mean.C/mean.E
```

And the log of the ratio is
```{r}
log(mean.C/mean.E)

```

Due to some obscure math, the variance (vi) for a difference between two means is calcualted using a weighted average, while the variance for a ratio of two means has a very different formula.

MD, SMD, SMDH, ROM

## escalc formula notation 

escalc() can also work with a formula notation similar to how the lm() function works.  The notation is a bit complex though.  This notation is very useful for when you have data summarized in "long" format from dplyr, so its worth the effort to see how it work.s

escalc's formulat notation has these features:

* Left-hand side of formula: "mean/sd" for the effect size
* Right-hand side of formula: "~ grouping.var | study.var", where "grouping.var" is a categorical variable that distinquishes the 2 treatments within a study or experiment, and "| study.var" is a categorical variable that distinguishes between different studies, experiments, or datsets.  In our data, the grouping variable is "E.or.C", for the Experimental or Control treatment, and the study variable is "student.ID", which distinquishes the seperate datasets generated by each students, which we are treating like unique experiments for our quasi-meta analysis.
* The sample size is indicated by "weights = n"
* The data set being used, set by "data = ..."

"student.ID" is a numeric variable.  In the code below we wrap it in factor() to convert it to a categorical variable.  We could also set it to a facto in the dataframe like this

```{r}
sxn1_summary$student.ID <- factor(sxn1_summary$student.ID)
```


### escalc formula notation demonstration

Let's recalcuate the effect size for the 1st able allele. Note that for the dataset I am using the summary datset we made of just the able 1 allele, which has only 2 rows

```{r, echo = F}
abl.1
```


Now let's get our effect size. 
```{r}
escalc(mean/sd ~ E.or.C | factor(student.ID),
       weights = n,
       measure = "SMD", 
       data = abl.1)
```


This should be the same result as our previous way of using escalc()

```{r}
escalc(m1i = mean.C, m2i = mean.E, 
                sd1i = sd.C, sd2i = sd.E,
                n1i = n.C, n2i = n.E,
                measure = "SMD")
```

### escalc formula notation application

Now let's use the full dataset, sxn1_summary, which has data on all 18 alleles.  The only diference is the dataset I'm using (data = sxn1_summary) and I've added "var.names =..." to give the output informative labels.


```{r}
sx1n1_SMD <- escalc(mean/sd ~ E.or.C | factor(student.ID),
       weights = n,
       measure = "SMD", 
       data = sxn1_summary,
       var.names = c("mean.diff","var"),
       append = T)
```












```{r}
cols.to.use <- c("gene.allele","allele","E.or.C","mean")
spread(data = sxn1_summary[,cols.to.use],
       key = "E.or.C", 
       value = "mean")
```



```{r}
library(data.table)
sxn1_wide <- dcast.data.table(data = data.table(sxn1_summary),
                 formula = gene.allele + allele ~ E.or.C,
                 value.var = c("mean","sd","n"))
sxn1_wide <- as.data.frame(sxn1_wide)


sxn1_wide$mean.diff <- sxn1_wide$mean_C - sxn1_wide$mean_E
```



```{r}
names(sx1n1_mean_diff)
merge(sx1n1_mean_diff,sxn1_wide, by  = "mean.diff")
```


```{r}

metafor:::escalc(measure = "ROM",
       m1i  = mean_C, m2i  = mean_E,
       sd1i = sd_C,  sd2i = sd_E,
       n1i  = n_C,   n2i = n_E,
       data = na.omit(sxn1_wide))
```




```{r}

```

```{r}
forest(x = sx1n1_mean_diff$mean.diff, 
       vi = sx1n1_mean_diff$var,
       annotate = F,
       xlim = c(-2.75,3.25))
```

